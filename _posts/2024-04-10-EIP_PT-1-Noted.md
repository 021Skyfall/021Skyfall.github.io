---
title: "정보처리기사 실기 1 / 요구사항 확인"
author: Jeremiah Lee
date: 2024-04-10
categories: [ 정보처리기사, 실기 ]
tags: [자격증]
pin: false
math: true
mermaid: true
image: 
  path: /assets/img/Certificates/EIP/Certificate_jelly.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: 
---
***

실기 시험 준비

수제비 2023 참조
[코딩하는 핑가 블로그](https://ss-o.tistory.com/95?category=945579) 참조

<br>
<br>
<br>

# C1. 소프트웨어 개발 방법론

## i. 소프트웨어 개발 방법론

### A. 소프트웨어 생명주기 모델

#### 1. 소프트웨어 생명 주기 모델 개념
   - 개념 : 소프트웨어 생명주기는 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차

<br>

#### 2. 소프트웨어 생명주기 모델 프로세스
   - **요구사항 분석** : 개발할 소프트웨어의 기능과 제약 조건, 목표 등을 소프트웨어 사용자와 함께 명확히 정의하는 단계
     - 기능 요구사항 / 비기능 요구사항
   - **설계** : 시스템 명세 단계에서 정의한 기능을 실제 수행할 수 있도록 수행방법을 논리적으로 결정하는 단계
     - 시스템 구조 설계 / 프로그램 설계 / UI 설계
   - **구현** : 설계 단계에서 논리적으로 결정한 문제 해결 방법을 특정 프로그래밍 언어를 사용하여 실제 프로그램을 작성하는 단계
     - 인터페이스 개발 / 자료 구조 개발 / 오류 처리
   - **테스트** : 시스템이 정해진 요구를 만족하는지, 예상과 실제 결과가 어떤 차이를 보이는지 검사하고 평가하는 단계
     - 단위 / 통합 / 시스템 / 인수 테스트
   - **유지보수** : 시스템이 인수되고 설치된 후 일어나는 모든 행동
     - 예방 / 완전 / 교정 / 적응 유지보수

<br>

#### 3. 소프트웨어 생명주기 모델 종류
   - **폭포수 모델 (WaterFall)** : 개발 시 각 단계를 확실히 마무리 후 다음 단계로 넘어감 
     - 가장 오래됨 / 선형 / 고전적 / 명확 / 요구사항 변경 어려움
     - 절차 : 검토 → 계획 → 분석 → 설계 → 구현 → 테스트 → 유지보수
   - **프로토타이핑 모델** : 주요 기능을 프로토타입으로 구현, 피드백을 반영하여 개발
     - 프로토타입 / 분석 용이 / 검증 가능 / 프로토타입 폐기 시 비용 증가
     - 발주자, 개발자 모두에게 공동의 참조 모델을 제공 / 구현 단계의 구현 골격
   - **나선형 모델** : 시스템 개발 시 위험을 최소화하기 위해 점진적으로 개발
     - 위험분석 / 반복개발 / 위험성 감소 / 유연 대처 / 관리 어려움
     - 절차 : 계획 및 정의 → 위험 분석 → 개발 → 고객 평가
   - **반복적 모델** : 병렬적으로 개발 후 통합, 혹은 반복적으로 개발
     - 증분방식 병행 개발 / 일정 단축 / 관리 비용 증가


<br>
<br>

### B. 소프트웨어 개발 방법론

#### 1. 소프트웨어 개발 방법론 개념
  - 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법
  - 소프트웨어를 하나의 생명체로 간주, 시작부터 끝까지 전 과정을 형상화한 방법론

<br>

#### 2. 소프트웨어 개발 방법론 종류
  - **구조적 방법론** : 전체 시스템을 기능에 따라 나누어 개발, 이를 통합하는 분할과 정복 접근 방식의 방법론
    - 프로세스 중심의 하향식
    - 나씨-슈나이더만 차트 사용
  - **정보공학 방법론** : 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
    - 개발 주기 활용, 대형 프로젝트 수행
  - **객체 지향 방법론** : 객체 단위로 시스템을 분석 및 설계하는 방법론
    - 객체, 클래스, 메시지 사용
  - **컴포넌트 기반 방법론** : 컴포넌트를 조립해서 하나의 새로운 프로그램을 작성하는 방법론
    - 개발 기간 단축 / 기능 추가 용이 / 재사용 가능
  - **애자일 방법론** : 절차보다는 사람이 중심, 변화에 유연하고 신속하게 적응하면서 효율적으로 개발하는 방법론
    - 개발 과정의 어려움 극복
  - **제품 계열 방법론** : 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
    - 영역 공학(영역 분석, 영역 설계, 자산 구현)과 응용 공학(요구분석, 제품 설계, 제품 구현)으로 구분

<br>

#### 3. 애자일(Agile)
  - 절차보다는 사람이 중심, 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템 개발
  - 짧고 신속, 폭포수 모형에 대비되는 방법론
  - 기존 개발 방법론의 한계 극복을 위해 등장
  - 유동적 / 팀 중심 / 반복 주기 / 문서보다 코드
  - 유형
    - **XP (eXtreme Programming)**
      - 의사소통 개선, 즉각 피드백
      - 1 ~ 3주 반복 개발주기
      - 가치
        - 용기, 단순성, 의사소통, 피드백, 존중
      - 기본원리
        - 페어 프로그래밍, 공동 코드 소유, 지속적인 통합, 계획 세우기, 작은 릴리즈, 메타포어(공통적인 이름 체계, 시스템 서술서를 통해 의사소통), 간단한 디자인, 테스트 기반 개발, 리팩토링, 40시간 작업, 고객 상주, 코드 표준
    - **린 (Lean)**
      - 도요타의 린 시스템 품질기법을 적용
      - 낭비 요소 제거
      - 원칙
        - 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화
    - **스크럼**
      - 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론
      - 2 ~ 4주 단위 스프린트
      - 주요 개념
        - 백로그, 스프린트, 스크럼 미팅(매일), 스크럼 마스터, 스프린트 회고, 번 다운 차트(남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트 / 수직축 : 백로그, 수평축 : 시간)

<br>
<br>

### C. 객체 지향 분석 방법론

#### 1. 객체 지향 개념
  - 객체 지향은 실세계의 개체를 속성과 메서드가 결합한 형태의 객체로 표현하는 기법

<br>

#### 2. 객체 지향 구성 요소
  - **클래스** : 특정 객체 내에 있는 변수와 메서드를 정의하는 틀
  - **객체** : 물리적, 추상적으로 자신과 다른 것을 식별 가능한 대상
  - **메서드** : 클래스로부터 생성된 객체를 사용하는 방법
  - **메시지** : 객체 간 상호 작용을 하기 위한 수단
  - **인스턴스** : 객체 지향 기법에서 클래스를 통해 만든 실제의 실형 객체
  - **속성** : 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의

<br>

#### 3. 객체 지향 기법
  - **캡슐화**
    - 서로 연관된 데이터와 함수를 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 기법
    - 결합도 낮음 / 재사용 용이
    - 인터페이스 단순화
    - 정보 은닉
  - **상속성**
    - 상위 클래스의 속성과 메서드를 하위 클래스에서 재정의 없이 물려받아 사용하는 기법
  - **다형성**
    - 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
    - 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질
    - 오버로딩(같은 이름 / 다른 매개변수) / 오버라이딩(상속 관계에서 상위의 메서드를 하위에서 재정의)
  - **추상화**
    - 공통 성질을 추출하여 추상 클래스를 설정하는 기법
    - 과정 추상화 / 자료 추상화 / 제어 추상화
  - **정보 은닉**
    - 코드 내부 데이터와 메서드를 숨기고 공개 인터페이스를 통해 접근이 가능하도록 하는 코드 보안 기술
    - 필요하지 않은 정보는 접근할 수 없도록 설계
    - 요구사항 등 변화에 따른 수정 용이
  - **관계성**
    - 두 개 이상의 엔티티 형에서 데이터를 참조하는 관계를 나타내는 기법
    - 연관화
      - is-member-of 관계
    - 집단화
      - is-part-of 관계 / part-whole 관계
    - 분류화
      - is-instance-of 관계
    - 일반화
      - is-a 관계
      - 클래스들 간의 개념적인 포함 관계
    - 특수화
      - is-a 관계
      - 상위 클래스의 특성들을 상속 받으면서 하위 클래스가 수정하고 고유특성을 갖는 관계

<br>

#### 4. 객체 지향 설계 원칙 (SOLID)
  - 단일 책임 원칙 (SRP)
    - 하나의 클래스는 하나의 책임만
  - 개방 폐쇄 원칙 (OCP)
    - 확장에는 열려있고, 변경에는 닫혀있어야함
  - 리스코프의 치환 원칙 (LSP)
    - (상속 관계에서) 하위 클래스는 상위 클래스로 교체할 수 있어야함
  - 인터페이스 분리 원칙 (ISP)
    - 사용하지 않는 인터페이스는 구현하지 말아야함
  - 의존 역전 원칙 (DIP)
    - 사용 관계 변경 없이 추상을 매개로 메시지를 주고 받음으로 관계 느슨하게

<br>

#### 5. 객체 지향 분석의 개념
  - 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 속성과 연산, 관계를 정의하여 모델링하는 기법

<br>

#### 6. 객체 지향 분석 방법론 종류
  - **OOSE (Object Oriented Software Engineering)**
    - 야콥슨
    - 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용
    - 분석-설계-구현 단계
    - 기능적 요구사항 중심 시스템
  - **OMT (Object Modeling Technology)**
    - 럼바우
    - 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론
    - 분석 절차 : 객체 모델링 → 동적 모델링 → 기능 모델링 순
      - 객체 모델링
        - 정보 모델링
        - 시스템에서 요구하는 객체를 찾고 객체들 간의 관계를 정의하여 ER 다이어그램 제작
        - 객체 다이어그램 활용
      - 동적 모델링
        - 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현
        - 상태 다이어그램 활용
      - 기능 모델링
        - 프로세스들의 자료 흐름을 중심으로 처리 과정 표현
        - 자료 흐름도 (DFD) 활용
  - **OOD (Object Oriented Design)**
    - 부치
    - 설계 문서화를 강조, 다이어그램 중심으로 개발하는 방법론
    - 분석과 설계의 분리가 불가
  - **코드-요든**
    - E-R 다이어그램 사용, 객체의 행위 모델링
  - **워프-브록**
    - 분석과 설계 간 구분 없음

<br>

#### 7. 기능 모델링 주요 기법
  - 데이터 흐름도 (DFD)
    - 자료 흐름 그래프 또는 버블 차트
    - 데이터가 각 프로세스를 따라 흐르면서 변환되는 모습을 나타낸 그림
    - 구조적 분석 기법에서 활용
    - 데이터 흐름에 중심을 둠
    - 제어 흐름은 중요치 않음
    - 시간 흐름 명확치 않음
  - 자료 사전 (DD)
    - 자료 요소, 자료 요소들의 집합, 자료의 흐름, 자료 저장소의 의미와 관계, 값, 범위, 단위들을 구체적으로 명시하는 사전
    - 조직 속 다른 이에게 특정한 자료 용어가 무엇을 의미하는 지 알려주기 위함

<br>
<br>
<br>

## ii. 프로젝트 관리

### A. 프로젝트 관리

#### 1. 프로젝트 관리의 개념
  - 프로젝트 관리는 주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적인 활동
  - 소프트웨어 생명 주기의 전과정에 걸쳐서 진행

<br>

#### 2. 프로젝트 관리 대상
  - **계획 관리** : 프로젝트 계획, 비용 산정, 일정 계획, 조직 계획에 대한 관리
  - **품질 관리** : 품질 통제 및 품질 보증
  - **범위 관리** : 이해관계자가 요청한 모든 요구사항이 프로젝트 범위에 포함되었는지 보장하고, 필요한 작업만 수행될 수 있도록 관리

<br>

#### 3. 프로젝트 관리 3대 요소
  - **사람** : 기본이 되는 인적 자원
  - **문제** : 사용자 입장에서 문제 분석 인식
  - **프로세스** : 서프트웨어 개발에 필요한 전체적인 작업 계획 및 구조

<br>
<br>

### B. 비용산정 모형

#### 1. 비용산정 모형 개념
  - 소프트웨어 규모파악을 통한 투입자원, 소요시간을 파악 후 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식

<br>

#### 2. 비용산정 모형 분류
  - **하향식 산정방법**
    - 전문가에게 의뢰 혹은 조정자를 통해 산정
    - 델파이 기법 : 전문가의 지식을 통한 문제해결 및 미래예측 산정
  - **상향식 산정방법**
    - 세부적인 요구사항과 기능에 따라 필요한 비용 계산
    - 코드 라인 수(LoC) / Man Month / COCOMO / 푸트남 / 기능점수(FP)

<br>

#### 3. 비용산정 모형 종류
  - **LoC**
    - 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정 후 예측치를 구해 비용 산정
    - (낙관치 + (4 * 중간치) + 비관치) / 6
  - **Man Month**
    - 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 산정
    - Man Month = LoC / 프로그래머 월간 생산성
    - 프로젝트 기간 = Man Month / 프로젝트 인력
  - **COCOMO**
    - 보헴이 제안
    - 프로그램 규모에 따라 비용 산정
    - 개발비 견적에 널리 통용
    - 조직형 (Organic Mode)
      - 중/소규모 소프트웨어, 5만 라인 이하
      - 반 분리형 (Semi-Detached Mode)
      - 중규모 소프트웨어, 30만 라인 이하
    - 임베디드형 (Embedded Mode)
      - 대규모 소프트웨어, 30만 라인 이상
  - **푸트남(Putnam)**
    - 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정
    - 생명주기 예측 모형
  - **기능점수(Function Point)**
    - 요구 기능을 증가시키는 인자별로 가중치 부여, 요인별 가중치 합산 후 총 기능 점수 계산
    - 기능점수 = 총 기능점수 * [0.65 (0.1 * 총 영향도)]

<br>
<br>

### C. 일정관리 모델

#### 1. 일정관리 모델 개념
  - 프로젝트가 일정 기한 내에 적절하게 완료될 수 있도록 관리하는 모델

<br>

#### 2. 일정관리 모델 종류
  - **주 공정법(CPM)**
    - 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 기법
    - 프로젝트 시작에서 종료까지 가장 긴 시간이 걸리는 경로
  - **PERT**
    - 일의 순서를 계획적으로 정리하기 위한 수렴 기법
    - 비관치, 중간치, 낙관치 3점 추정방식을 통해 일정 관리
  - **중요 연쇄 프로젝트 관리(CCPM)**
    - 주 공정 연쇄법
    - 자원제약사항을 고려하여 일정 작성

<br>
<br>

### D. 위험 관리

#### 1. 위험 관리 개념
  - 내재된 위험 요소 인식, 영향 분석 후 관리하는 활동

<br>

#### 2. 위험의 종류
  - **알려진 위험** : 프로젝트 계획서, 기술적 환경, 정보 등에 의해 발견
  - **예측 가능한 위험** : 과거 경험으로부터 예측
  - **예측 불가능한 위험** : 사전 예측이 매우 어려움

<br>

#### 3. 위험 대응 전략
  - **회피** : 발생 가능성을 원천적으로 제거
  - **전가** : 위험에 대한 책임을 제3자에게 전가
  - **완화** : 위험 발생 가능성 감소, 혹은 영향력 감소
  - **수용** : 위험을 그대로 받아들임

<br>
<br>
<br>
<br>

# C2. 현행 시스템 분석

## i. 현행 시스템 파악

### A. 현행 시스템 파악 개념
  - 현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 연계 정보는 무엇이며 어떤 기술 요소를 사용하는지를 파악하는 활동

### B. 현행 시스템 파악 절차
  - **1단계** : 구성/기능/인터페이스 파악
  - **2단계** : 아키텍처/소프트웨어 구성 파악
  - **3단계** : 하드웨어/네트워크 구성 파악

<br>
<br>
<br>

## ii. 개발 기술 환경 정의

<br>
<br>
<br>
<br>

# C3. 요구사항 확인

## i. 요구사항

<br>
<br>
<br>

## ii. 요구사항의 시스템화 타당성 분석

















